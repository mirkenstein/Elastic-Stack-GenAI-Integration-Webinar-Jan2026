input {
  file {
    path => "/tmp/sample30.csv"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => multiline {
      # Pattern: lines that start with a digit (ID) followed by comma
      pattern => '^\d+,'
      negate => true
      what => "previous"
      auto_flush_interval => 10
    }
  }
}

filter {
  # Step 1: Replace the field separators (commas between fields)
  # Replace ", " with "|" but only when it's between fields
  # This pattern looks for: comma, space, quote
  mutate {
    gsub => [
      "message", ',"', '|"',
      "message", '\r\n', '\n',
      "message", '\r$', ''
    ]
  }
  # Parse the CSV
  csv {
    source => "message"
    columns => ["id_section_header", "section_text", "dialogue"]
    quote_char => '"'
    separator => "|"
  }

    # Clean up
  mutate {
    gsub => [
      "section_text", "\n", " ",
      "dialogue", "\n", " "
    ]
    strip => ["section_text", "dialogue"]
#    split => {
#      "ID-section_header", "id-array",","
#    }
    remove_field => ["message","log","host","","@version","@timestamp"]
  }

  # Clean up the fields
#  mutate {
#    gsub => [
#      "section_text", "\n", " ",
#      "dialogue", "\n", " "
#    ]
#    strip => ["section_text", "dialogue"]
#    convert => {
#      "ID" => "integer"
#    }
#  }

  # Remove the original message field
#  mutate {
#    remove_field => ["message"]
#  }
}

output {
  stdout {
    codec => rubydebug
  }
 file {
    path => "/tmp/medical-notes-%{+YYYY-MM-dd}.json"
    # Use json_lines for one JSON object per line
    codec => json_lines {
      # Optional: pretty print (makes file larger but readable)
#      pretty => true
    }
  }

}