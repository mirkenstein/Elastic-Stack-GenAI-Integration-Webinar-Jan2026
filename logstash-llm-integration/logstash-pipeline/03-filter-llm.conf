# Filter: Call Ollama LLM for classification
filter {
  # Escape quotes in dialogue for JSON body
  mutate {
    add_field => { "original_dialogue" => "%{dialogue}" }
    gsub => [
      "dialogue", '"', '\"',
      "dialogue", "\n", "\\n",
      "dialogue", "\r", ""
    ]
  }

  # Call Ollama with phi4-mini model
  http {
    url => "http://localhost:11434/v1/chat/completions"
    verb => "POST"
    headers => {
      "Content-Type" => "application/json"
    }
    body => '{
      "model": "phi4-mini",
      "messages": [
        {
          "role": "system",
          "content": "You are a medical documentation classifier. You analyze doctor-patient conversations and output ONLY valid JSON with no markdown formatting."
        },
        {
          "role": "user",
          "content": "Analyze this doctor-patient conversation and perform these tasks:\n\n1. Identify the PRIMARY diagnosis or medical concern\n2. Classify into exactly ONE of these 20 category codes:\n   - fam_sochx (Family/Social History)\n   - genhx (History of Present Illness)\n   - pastmedicalhx (Past Medical History)\n   - cc (Chief Complaint)\n   - pastsurgical (Past Surgical History)\n   - allergy\n   - ros (Review of Systems)\n   - medications\n   - assessment\n   - exam\n   - diagnosis\n   - disposition\n   - plan\n   - edcourse (Emergency Department Course)\n   - immunizations\n   - imaging\n   - gynhx (Gynecologic History)\n   - procedures\n   - other_history\n   - labs\n\n3. Write a brief clinical summary (2-3 sentences) with the diagnosis at the beginning\n\nIMPORTANT: Output ONLY a valid JSON object. No markdown, no code blocks, no explanation.\n\nRequired JSON format:\n{\"section_header\": \"category_code\", \"section_text\": \"Diagnosis: [diagnosis]. [Brief summary]\"}\n\nConversation:\n%{dialogue}"
        }
      ],
      "temperature": 0.3
    }'
    body_format => "json"
    target_body => "ollama_response"
    connect_timeout => 30
    request_timeout => 120
    socket_timeout => 120
    pool_max => 1
  }

  # Parse LLM response
  ruby {
    code => '
      response = event.get("ollama_response")

      if response.is_a?(Hash) && response["choices"] && response["choices"][0]
        content = response["choices"][0]["message"]["content"].strip

        json_match = content.match(/\{[^{}]*"section_header"[^{}]*"section_text"[^{}]*\}/m)

        if json_match
          begin
            parsed = JSON.parse(json_match[0])
            event.set("generated_section_header", parsed["section_header"])
            event.set("generated_section_text", parsed["section_text"])
            event.set("llm_raw_response", content)
            event.set("parse_status", "success")
          rescue JSON::ParserError => e
            event.set("generated_section_header", "parse_error")
            event.set("generated_section_text", "Failed to parse JSON: #{e.message}")
            event.set("llm_raw_response", content)
            event.set("parse_status", "json_parse_error")
          end
        else
          event.set("generated_section_header", "no_json_found")
          event.set("generated_section_text", content)
          event.set("llm_raw_response", content)
          event.set("parse_status", "no_json_in_response")
        end
      else
        event.set("generated_section_header", "llm_error")
        event.set("generated_section_text", "No valid response from Ollama")
        event.set("llm_raw_response", response.to_s)
        event.set("parse_status", "ollama_error")
      end
    '
  }

  # Cleanup intermediate fields
  mutate {
    remove_field => ["ollama_response", "message", "dialogue", "@version", "host", "log", "event"]
  }
}
