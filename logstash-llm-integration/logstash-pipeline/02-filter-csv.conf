# Filter: Parse MEDIQA CSV format
filter {
  # Skip header row
  if [message] =~ /^ID,/ {
    drop { }
  }

  # Normalize line endings
  mutate {
    gsub => [
      "message", '\r\n', '\n',
      "message", '\r', ''
    ]
  }

  # Parse CSV with ruby - handles both quoted and unquoted section_text
  # Format: ID,SECTION_HEADER,section_text (maybe quoted),"dialogue (always quoted)"
  ruby {
    code => '
      msg = event.get("message")
      next unless msg

      # The dialogue field starts with ," followed by a speaker (word + colon) and ends with "
      # Speakers can be: Doctor, Patient, Guest_clinician, Guest_family, etc.
      # Note: Some records have escaped quotes at start (,""" = ," + "" escaped quote)
      dialogue_match = msg.match(/,\"\"{0,2}((?:Doctor|Patient|Guest_clinician|Guest_family):.*)\"$/m)

      if dialogue_match
        dialogue = dialogue_match[1]
        rest = msg[0...dialogue_match.begin(0)]

        # rest is now: ID,SECTION_HEADER,section_text (possibly quoted)
        # Split on first two commas only
        parts = rest.split(",", 3)

        if parts.length >= 3
          event.set("id", parts[0].strip)
          event.set("section_header", parts[1].strip)

          # section_text might have surrounding quotes - remove them
          section_text = parts[2].strip
          if section_text.start_with?("\"") && section_text.end_with?("\"")
            section_text = section_text[1..-2]
          end
          event.set("section_text", section_text)
          event.set("dialogue", dialogue)
        end
      end
    '
  }

  # Skip if parsing failed
  if ![dialogue] or [dialogue] == "" {
    drop { }
  }

  # Clean up whitespace
  mutate {
    gsub => [
      "section_text", "\n", " ",
      "dialogue", "\n", " "
    ]
    strip => ["section_text", "dialogue"]
  }
}
